//! # Prediction Markets
//!
//! A module for creating, reporting, and disputing prediction markets.
//!
//! ## Overview
//!
//! Prediction markets are speculative markets that trade on future outcomes. While
//! a prediction market is active, traders can permissionlessly trade on outcome assets.
//! Complete set of outcome assets can be generated by exchanging base currency (ZTG) at
//! a 1:1 exchange rate, meaning that 1 ZTG is used to generate 1 of each outcome asset
//! of the market. A complete set of outcome assets (an equal amount of each outcome asset
//! for a market), can be used to do the reverse exchange, being used to exchange 1:1 back to ZTG.
//!
//! This pallet implements a two types of prediction markets:
//! - **Categorical market** - A market that can trade up to 8 different categories of outcomes. In the most
//! simple case, when the outcomes are binary options (i.e. "YES" or "NO") the market has only two categories.
//! - **Scalar markets** - A market that trades `Long` or `Short` positions on a range of outcomes.
//!
//! ## Interface
//!
//! ### Dispatches
//!
//! #### Public Dispatches
//!
//! - `buy_complete_set` - Buys a complete set of outcome assets for a market.
//! - `cancel_pending_market` - Allows the proposer of a market that is currently in a `Proposed` state to cancel the market proposal.
//! - `create_categorical_market` - Creates a new categorical market.
//! - `create_scalar_market` - Creates a new scalar market.
//! - `deploy_swap_pool_for_market` - Deploys a single "canonical" pool for a market.
//! - `dispute` - Submits a disputed outcome for a market.
//! - `global_dispute` - `unimplemented!()`
//! - `redeem_shares` - Redeems the winning shares for a market.
//! - `report` - Reports an outcome for a market.
//! - `sell_complete_set` - Sells a complete set of outcome assets for a market.
//!
//! #### Admin Dispatches
//!
//! The administrative dispatches are used to perform admin functions on chain. Currently, the
//! admin functions can only be called by the `ApprovalOrigin` origin.
//!
//! - `admin_destroy_market` - Destroys a market and all related assets, regardless of its state.
//! - `admin_move_market_to_closed` - Immediately moves a market that is an `Active` state to closed.
//! - `admin_move_market_to_resolved` - Immediately moves a market that is `Reported` or `Disputed` to resolved.
//!
//! #### `ApprovalOrigin` Dispatches
//!
//! The `ApprovalOrigin` is meant to be the advisory committee, the on-chain governing body of Zeitgeist
//! that is responsible for maintaining a list of high quality markets and slash low quality markets.
//!
//! - `approve_market` - Approves a `Proposed` market that is waiting approval from the Advisory Committee.
//! - `reject_market` -  Rejects a `Proposed` market that is waiting approval from the Advisory Committee.

#![cfg_attr(not(feature = "std"), no_std)]

extern crate alloc;

mod benchmarks;
mod migrations;
pub mod mock;
mod tests;
pub mod weights;

pub use pallet::*;

#[frame_support::pallet]
mod pallet {
    use crate::weights::*;
    use alloc::{vec, vec::Vec};
    use core::{cmp, marker::PhantomData};
    use frame_support::{
        dispatch::{self, DispatchResultWithPostInfo, Weight},
        ensure, log,
        storage::{with_transaction, TransactionOutcome},
        traits::{
            Currency, EnsureOrigin, ExistenceRequirement, Get, Hooks, IsType, OnUnbalanced,
            ReservableCurrency, Time,
        },
        transactional, PalletId,
    };
    use frame_system::{ensure_signed, pallet_prelude::OriginFor};
    use orml_traits::MultiCurrency;
    use sp_arithmetic::per_things::Perbill;
    use sp_runtime::{
        traits::{AccountIdConversion, Zero},
        DispatchResult, SaturatedConversion,
    };
    use zeitgeist_primitives::{
        traits::{DisputeApi, Swaps, ZeitgeistMultiReservableCurrency},
        types::{
            Asset, Market, MarketCreation, MarketEnd, MarketStatus, MarketType, MultiHash,
            OutcomeReport, Report, ResolutionCounters, ScalarPosition,
        },
    };
    use zrml_market_commons::MarketCommonsPalletApi;
    use zrml_simple_disputes::SimpleDisputesPalletApi;

    pub(crate) type BalanceOf<T> =
        <CurrencyOf<T> as Currency<<T as frame_system::Config>::AccountId>>::Balance;
    pub(crate) type CurrencyOf<T> =
        <<T as Config>::MarketCommons as MarketCommonsPalletApi>::Currency;
    pub(crate) type MarketIdOf<T> =
        <<T as Config>::MarketCommons as MarketCommonsPalletApi>::MarketId;
    type NegativeImbalanceOf<T> =
        <CurrencyOf<T> as Currency<<T as frame_system::Config>::AccountId>>::NegativeImbalance;

    #[pallet::call]
    impl<T: Config> Pallet<T> {
        /// Allows the `ApprovalOrigin` to immediately destroy a market.
        ///
        /// todo: this should check if there's any outstanding funds reserved if it stays
        /// in for production
        #[pallet::weight(
            T::WeightInfo::admin_destroy_reported_market(
                4_500,
                4_500,
                T::MaxCategories::get() as u32
            ).max(T::WeightInfo::admin_destroy_disputed_market(
                4_500,
                4_500,
                T::MaxCategories::get() as u32
            ))
        )]
        pub fn admin_destroy_market(
            origin: OriginFor<T>,
            market_id: MarketIdOf<T>,
        ) -> DispatchResultWithPostInfo {
            T::ApprovalOrigin::ensure_origin(origin)?;

            let mut total_accounts = 0usize;
            let mut share_accounts = 0usize;
            let market = T::MarketCommons::market(&market_id)?;
            let market_status = market.status;
            let outcome_assets = Self::outcome_assets(market_id, &market);
            let outcome_assets_amount = outcome_assets.len();
            Self::clear_auto_resolve(&market_id)?;
            T::MarketCommons::remove_market(&market_id)?;

            let mut outcome_assets_iter = outcome_assets.into_iter();

            // Delete of this market's outcome assets.
            let mut manage_outcome_asset = |asset: Asset<_>| -> usize {
                let (total_accounts, accounts) = T::Shares::accounts_by_currency_id(asset);
                share_accounts = share_accounts.saturating_add(accounts.len());
                T::Shares::destroy_all(asset, accounts.iter().cloned());
                total_accounts
            };

            if let Some(first_asset) = outcome_assets_iter.next() {
                total_accounts = manage_outcome_asset(first_asset);
            }
            for asset in outcome_assets_iter {
                let _ = manage_outcome_asset(asset);
            }

            // Weight correction
            if market_status == MarketStatus::Reported {
                Ok(Some(T::WeightInfo::admin_destroy_reported_market(
                    total_accounts.saturated_into(),
                    share_accounts.saturated_into(),
                    outcome_assets_amount.saturated_into(),
                ))
                .into())
            } else if market_status == MarketStatus::Disputed {
                Ok(Some(T::WeightInfo::admin_destroy_disputed_market(
                    total_accounts.saturated_into(),
                    share_accounts.saturated_into(),
                    outcome_assets_amount.saturated_into(),
                ))
                .into())
            } else {
                Ok(None.into())
            }
        }

        /// Allows the `ApprovalOrigin` to immediately move an open market to closed.
        #[pallet::weight(T::WeightInfo::admin_move_market_to_closed())]
        pub fn admin_move_market_to_closed(
            origin: OriginFor<T>,
            market_id: MarketIdOf<T>,
        ) -> DispatchResult {
            T::ApprovalOrigin::ensure_origin(origin)?;

            let market = T::MarketCommons::market(&market_id)?;
            let new_end = match market.end {
                MarketEnd::Block(_) => {
                    let current_block = <frame_system::Pallet<T>>::block_number();
                    MarketEnd::Block(current_block)
                }
                MarketEnd::Timestamp(_) => {
                    let now = T::Timestamp::now().saturated_into::<u64>();
                    MarketEnd::Timestamp(now)
                }
            };

            T::MarketCommons::mutate_market(&market_id, |m| {
                m.end = new_end;
                Ok(())
            })?;
            Ok(())
        }

        /// Allows the `ApprovalOrigin` to immediately move a reported or disputed
        /// market to resolved.
        ////
        #[pallet::weight(T::WeightInfo::admin_move_market_to_resolved_overhead()
            .saturating_add(T::WeightInfo::internal_resolve_categorical_reported(
                4_200,
                4_200,
                T::MaxCategories::get() as u32
            ).saturating_sub(T::WeightInfo::internal_resolve_scalar_reported())
        ))]
        pub fn admin_move_market_to_resolved(
            origin: OriginFor<T>,
            market_id: MarketIdOf<T>,
        ) -> DispatchResultWithPostInfo {
            T::ApprovalOrigin::ensure_origin(origin)?;

            let market = T::MarketCommons::market(&market_id)?;
            ensure!(
                market.status == MarketStatus::Reported || market.status == MarketStatus::Disputed,
                "not reported nor disputed"
            );
            Self::clear_auto_resolve(&market_id)?;
            let market = T::MarketCommons::market(&market_id)?;
            let rc = T::SimpleDisputes::internal_resolve(&market_id, &market)?;
            Ok(Some(
                Self::calculate_internal_resolve_weight(&market, rc)
                    .saturating_add(T::WeightInfo::admin_move_market_to_resolved_overhead())
                    .saturating_sub(T::WeightInfo::internal_resolve_scalar_reported()),
            )
            .into())
        }

        /// Approves a market that is waiting for approval from the
        /// advisory committee.
        ///
        /// NOTE: Returns the proposer's bond since the market has been
        /// deemed valid by an advisory committee.
        ///
        /// NOTE: Can only be called by the `ApprovalOrigin`.
        ///
        #[pallet::weight(T::WeightInfo::approve_market())]
        pub fn approve_market(origin: OriginFor<T>, market_id: MarketIdOf<T>) -> DispatchResult {
            T::ApprovalOrigin::ensure_origin(origin)?;

            let market = T::MarketCommons::market(&market_id)?;

            let creator = market.creator;

            CurrencyOf::<T>::unreserve(&creator, T::AdvisoryBond::get());
            T::MarketCommons::mutate_market(&market_id, |m| {
                m.status = MarketStatus::Active;
                Ok(())
            })?;

            Self::deposit_event(Event::MarketApproved(market_id));
            Ok(())
        }

        /// Buys the complete set of outcome shares of a market. For example, when calling this
        /// function on a categorical market with five different outcomes, five different shares
        /// will be transferred to the callee.
        ///
        /// The amount of each share will equal the provided `amount` parameter.
        ///
        /// NOTE: This is the only way to create new shares.
        // Note: `buy_complete_set` weight consumption is dependent on how many assets exists.
        // Unfortunately this information can only be retrieved with a storage call, therefore
        // The worst-case scenario is assumed and the correct weight is calculated at the end of this function.
        // This also occurs in numerous other functions.
        #[pallet::weight(
            T::WeightInfo::buy_complete_set(T::MaxCategories::get() as u32)
        )]
        #[transactional]
        pub fn buy_complete_set(
            origin: OriginFor<T>,
            market_id: MarketIdOf<T>,
            #[pallet::compact] amount: BalanceOf<T>,
        ) -> DispatchResultWithPostInfo {
            let sender = ensure_signed(origin)?;
            Self::do_buy_complete_set(sender, market_id, amount)
        }

        #[pallet::weight(T::WeightInfo::dispute(T::SimpleDisputes::max_disputes()))]
        pub fn dispute(
            origin: OriginFor<T>,
            market_id: MarketIdOf<T>,
            outcome: OutcomeReport,
        ) -> DispatchResultWithPostInfo {
            let [weight, max_weight] = T::SimpleDisputes::on_dispute(origin, market_id, outcome)?;
            Self::calculate_actual_weight(&T::WeightInfo::dispute, weight, max_weight)
        }

        /// NOTE: Only for PoC probably - should only allow rejections
        /// in a production environment since this better aligns incentives.
        /// See also: Polkadot Treasury
        ///
        #[pallet::weight(T::WeightInfo::cancel_pending_market())]
        pub fn cancel_pending_market(
            origin: OriginFor<T>,
            market_id: MarketIdOf<T>,
        ) -> DispatchResult {
            let sender = ensure_signed(origin)?;

            let market = T::MarketCommons::market(&market_id)?;

            let creator = market.creator;
            let status = market.status;
            ensure!(creator == sender, "Canceller must be market creator.");
            ensure!(status == MarketStatus::Proposed, "Market must be pending approval.");
            // The market is being cancelled, return the deposit.
            CurrencyOf::<T>::unreserve(&creator, T::AdvisoryBond::get());
            T::MarketCommons::remove_market(&market_id)?;
            Self::deposit_event(Event::MarketCancelled(market_id));
            Ok(())
        }

        #[pallet::weight(T::WeightInfo::create_categorical_market())]
        pub fn create_categorical_market(
            origin: OriginFor<T>,
            oracle: T::AccountId,
            end: MarketEnd<T::BlockNumber>,
            metadata: MultiHash,
            creation: MarketCreation,
            categories: u16,
        ) -> DispatchResult {
            let sender = ensure_signed(origin)?;
            Self::ensure_create_market_end(end)?;

            ensure!(categories >= T::MinCategories::get(), <Error<T>>::NotEnoughCategories);
            ensure!(categories <= T::MaxCategories::get(), <Error<T>>::TooManyCategories);

            // Require sha3-384 as multihash.
            let MultiHash::Sha3_384(multihash) = metadata;
            ensure!(multihash[0] == 0x15 && multihash[1] == 0x30, <Error<T>>::InvalidMultihash);

            let status: MarketStatus = match creation {
                MarketCreation::Permissionless => {
                    let required_bond = T::ValidityBond::get() + T::OracleBond::get();
                    CurrencyOf::<T>::reserve(&sender, required_bond)?;
                    MarketStatus::Active
                }
                MarketCreation::Advised => {
                    let required_bond = T::AdvisoryBond::get() + T::OracleBond::get();
                    CurrencyOf::<T>::reserve(&sender, required_bond)?;
                    MarketStatus::Proposed
                }
            };

            let market = Market {
                creator: sender.clone(),
                creation,
                creator_fee: 0,
                oracle,
                end,
                metadata: Vec::from(multihash),
                market_type: MarketType::Categorical(categories),
                status,
                report: None,
                resolved_outcome: None,
            };

            let market_id = T::MarketCommons::push_market(market)?;

            Self::deposit_event(Event::MarketCreated(market_id, sender));

            Ok(())
        }

        #[pallet::weight(T::WeightInfo::create_scalar_market())]
        pub fn create_scalar_market(
            origin: OriginFor<T>,
            oracle: T::AccountId,
            end: MarketEnd<T::BlockNumber>,
            metadata: MultiHash,
            creation: MarketCreation,
            outcome_range: (u128, u128),
        ) -> DispatchResult {
            let sender = ensure_signed(origin)?;
            Self::ensure_create_market_end(end)?;

            ensure!(outcome_range.0 < outcome_range.1, "Invalid range provided.");

            // Require sha3-384 as multihash.
            let MultiHash::Sha3_384(multihash) = metadata;
            ensure!(multihash[0] == 0x15 && multihash[1] == 0x30, <Error<T>>::InvalidMultihash);

            let status: MarketStatus = match creation {
                MarketCreation::Permissionless => {
                    let required_bond = T::ValidityBond::get() + T::OracleBond::get();
                    CurrencyOf::<T>::reserve(&sender, required_bond)?;
                    MarketStatus::Active
                }
                MarketCreation::Advised => {
                    let required_bond = T::AdvisoryBond::get() + T::OracleBond::get();
                    CurrencyOf::<T>::reserve(&sender, required_bond)?;
                    MarketStatus::Proposed
                }
            };

            let market = Market {
                creator: sender.clone(),
                creation,
                creator_fee: 0,
                oracle,
                end,
                metadata: Vec::from(multihash),
                market_type: MarketType::Scalar(outcome_range),
                status,
                report: None,
                resolved_outcome: None,
            };

            let market_id = T::MarketCommons::push_market(market)?;

            Self::deposit_event(Event::MarketCreated(market_id, sender));

            Ok(())
        }

        /// Deploys a new pool for the market. This pallet keeps track of a single
        /// canonical swap pool for each market in `market_to_swap_pool`.
        ///
        /// The sender should have enough funds to cover all of the required
        /// shares to seed the pool.
        #[pallet::weight(
            T::WeightInfo::deploy_swap_pool_for_market(weights.len() as u32)
        )]
        #[transactional]
        pub fn deploy_swap_pool_for_market(
            origin: OriginFor<T>,
            market_id: MarketIdOf<T>,
            weights: Vec<u128>,
        ) -> DispatchResult {
            let sender = ensure_signed(origin)?;

            let market = T::MarketCommons::market(&market_id)?;
            // ensure the market is active
            let status = market.status;
            ensure!(status == MarketStatus::Active, Error::<T>::MarketNotActive);

            // ensure a swap pool does not already exist
            ensure!(T::MarketCommons::market_pool(&market_id).is_err(), Error::<T>::SwapPoolExists);

            let mut assets = Self::outcome_assets(market_id, &market);
            assets.push(Asset::Ztg);

            let pool_id = T::Swaps::create_pool(sender, assets, Zero::zero(), weights)?;

            T::MarketCommons::insert_market_pool(market_id, pool_id);
            Ok(())
        }

        /// Starts a global dispute.
        ///
        /// NOTE: Requires the market to be already disputed `MaxDisputes` amount of times.
        ///
        #[pallet::weight(10_000_000)]
        pub fn global_dispute(origin: OriginFor<T>, market_id: MarketIdOf<T>) -> DispatchResult {
            let _sender = ensure_signed(origin)?;
            let _market = T::MarketCommons::market(&market_id)?;
            // TODO: implement global disputes
            Ok(())
        }

        /// Redeems the winning shares of a prediction market.
        ///
        #[pallet::weight(T::WeightInfo::redeem_shares_categorical()
            .max(T::WeightInfo::redeem_shares_scalar())
        )]
        pub fn redeem_shares(
            origin: OriginFor<T>,
            market_id: MarketIdOf<T>,
        ) -> DispatchResultWithPostInfo {
            let sender = ensure_signed(origin)?;

            let market = T::MarketCommons::market(&market_id)?;
            let market_account = Self::market_account(market_id);

            ensure!(market.status == MarketStatus::Resolved, Error::<T>::MarketIsNotResolved);

            // Check to see if the sender has any winning shares.
            let resolved_outcome =
                market.resolved_outcome.ok_or(Error::<T>::MarketIsNotResolved)?;

            let winning_assets = match resolved_outcome {
                OutcomeReport::Categorical(category_index) => {
                    let winning_currency_id = Asset::CategoricalOutcome(market_id, category_index);
                    let winning_balance = T::Shares::free_balance(winning_currency_id, &sender);

                    ensure!(winning_balance > BalanceOf::<T>::zero(), Error::<T>::NoWinningBalance);

                    // Ensure the market account has enough to pay out - if this is
                    // ever not true then we have an accounting problem.
                    ensure!(
                        CurrencyOf::<T>::free_balance(&market_account) >= winning_balance,
                        Error::<T>::InsufficientFundsInMarketAccount,
                    );

                    vec![(winning_currency_id, winning_balance, winning_balance)]
                }
                OutcomeReport::Scalar(value) => {
                    let long_currency_id = Asset::ScalarOutcome(market_id, ScalarPosition::Long);
                    let short_currency_id = Asset::ScalarOutcome(market_id, ScalarPosition::Short);
                    let long_balance = T::Shares::free_balance(long_currency_id, &sender);
                    let short_balance = T::Shares::free_balance(short_currency_id, &sender);

                    ensure!(
                        long_balance > BalanceOf::<T>::zero()
                            || short_balance > BalanceOf::<T>::zero(),
                        Error::<T>::NoWinningBalance
                    );

                    let (bound_low, bound_high) =
                        if let MarketType::Scalar(range) = market.market_type {
                            range
                        } else {
                            return Err(Error::<T>::InvalidMarketType.into());
                        };

                    let calc_payouts = |final_value, low, high| -> (Perbill, Perbill) {
                        if final_value <= low {
                            return (Perbill::zero(), Perbill::one());
                        }
                        if final_value >= high {
                            return (Perbill::one(), Perbill::zero());
                        }

                        let payout_long: Perbill =
                            Perbill::from_rational(final_value - low, high - low);
                        (
                            payout_long,
                            Perbill::from_parts(
                                Perbill::one().deconstruct() - payout_long.deconstruct(),
                            ),
                        )
                    };

                    let (long_percent, short_percent) = calc_payouts(value, bound_low, bound_high);

                    let long_payout = long_percent.mul_floor(long_balance);
                    let short_payout = short_percent.mul_floor(short_balance);
                    // Ensure the market account has enough to pay out - if this is
                    // ever not true then we have an accounting problem.
                    ensure!(
                        CurrencyOf::<T>::free_balance(&market_account)
                            >= long_payout + short_payout,
                        Error::<T>::InsufficientFundsInMarketAccount,
                    );

                    vec![
                        (long_currency_id, long_payout, long_balance),
                        (short_currency_id, short_payout, short_balance),
                    ]
                }
            };

            for (currency_id, payout, balance) in winning_assets {
                // Destroy the shares.
                T::Shares::slash(currency_id, &sender, balance);

                // Pay out the winner.
                let remaining_bal = CurrencyOf::<T>::free_balance(&market_account);

                CurrencyOf::<T>::transfer(
                    &market_account,
                    &sender,
                    payout.min(remaining_bal),
                    ExistenceRequirement::AllowDeath,
                )?;
            }

            // Weight correction
            if let OutcomeReport::Categorical(_) = resolved_outcome {
                return Ok(Some(T::WeightInfo::redeem_shares_categorical()).into());
            } else if let OutcomeReport::Scalar(_) = resolved_outcome {
                return Ok(Some(T::WeightInfo::redeem_shares_scalar()).into());
            }

            Ok(None.into())
        }

        /// Rejects a market that is waiting for approval from the advisory
        /// committee.
        ///
        /// NOTE: Will slash the reserved `AdvisoryBond` from the market creator.
        ///
        #[pallet::weight(T::WeightInfo::reject_market())]
        pub fn reject_market(origin: OriginFor<T>, market_id: MarketIdOf<T>) -> DispatchResult {
            T::ApprovalOrigin::ensure_origin(origin)?;

            let market = T::MarketCommons::market(&market_id)?;
            let creator = market.creator;
            let (imbalance, _) = CurrencyOf::<T>::slash_reserved(&creator, T::AdvisoryBond::get());
            // Slashes the imbalance.
            T::Slash::on_unbalanced(imbalance);
            T::MarketCommons::remove_market(&market_id)?;
            Self::deposit_event(Event::MarketRejected(market_id));
            Ok(())
        }

        /// Reports the outcome of a market.
        ///
        #[pallet::weight(T::WeightInfo::report())]
        pub fn report(
            origin: OriginFor<T>,
            market_id: MarketIdOf<T>,
            outcome: OutcomeReport,
        ) -> DispatchResult {
            let sender = ensure_signed(origin)?;
            let current_block = <frame_system::Pallet<T>>::block_number();

            T::MarketCommons::mutate_market(&market_id, |market| {
                // TODO make this a conditional check
                // ensure!(outcome <= market.outcomes(), Error::<T>::OutcomeOutOfRange);
                ensure!(market.report.is_none(), Error::<T>::MarketAlreadyReported);

                // ensure market is not active
                ensure!(!Self::is_market_active(market.end), Error::<T>::MarketNotClosed);

                match market.end {
                    MarketEnd::Block(block) => {
                        // blocks
                        if current_block <= block + T::ReportingPeriod::get() {
                            ensure!(sender == market.oracle, Error::<T>::ReporterNotOracle);
                        } // otherwise anyone can be the reporter
                    }
                    MarketEnd::Timestamp(timestamp) => {
                        // unix timestamp
                        let now = T::Timestamp::now().saturated_into::<u64>();
                        let reporting_period_in_ms =
                            T::ReportingPeriod::get().saturated_into::<u64>() * 6000;
                        if now <= timestamp + reporting_period_in_ms {
                            ensure!(sender == market.oracle, Error::<T>::ReporterNotOracle);
                        } // otherwise anyone can be the reporter
                    }
                }

                market.report =
                    Some(Report { at: current_block, by: sender, outcome: outcome.clone() });
                market.status = MarketStatus::Reported;

                Ok(())
            })?;

            let rslt = T::SimpleDisputes::mutate_market_ids_per_report_block(&current_block, |v| {
                v.push(market_id);
            });
            if rslt.is_err() {
                T::SimpleDisputes::insert_market_id_per_report_block(
                    current_block,
                    vec![market_id],
                );
            }

            Self::deposit_event(Event::MarketReported(market_id, outcome));
            Ok(())
        }

        /// Destroys a complete set of outcomes shares for a market.
        ///
        #[pallet::weight(
            T::WeightInfo::sell_complete_set(T::MaxCategories::get() as u32)
        )]
        pub fn sell_complete_set(
            origin: OriginFor<T>,
            market_id: MarketIdOf<T>,
            #[pallet::compact] amount: BalanceOf<T>,
        ) -> DispatchResultWithPostInfo {
            let sender = ensure_signed(origin)?;

            let market = T::MarketCommons::market(&market_id)?;
            ensure!(Self::is_market_active(market.end), Error::<T>::MarketNotActive);

            let market_account = Self::market_account(market_id);
            ensure!(
                CurrencyOf::<T>::free_balance(&market_account) >= amount,
                "Market account does not have sufficient reserves.",
            );

            let assets = Self::outcome_assets(market_id, &market);

            // verify first.
            for asset in assets.iter() {
                // Ensures that the sender has sufficient amount of each
                // share in the set.
                ensure!(
                    T::Shares::free_balance(*asset, &sender) >= amount,
                    Error::<T>::InsufficientShareBalance,
                );
            }

            // write last.
            for asset in assets.iter() {
                T::Shares::slash(*asset, &sender, amount);
            }

            CurrencyOf::<T>::transfer(
                &market_account,
                &sender,
                amount,
                ExistenceRequirement::AllowDeath,
            )?;

            Self::deposit_event(Event::SoldCompleteSet(market_id, sender));
            let assets_len: u32 = assets.len().saturated_into();
            let max_cats: u32 = T::MaxCategories::get().into();
            Self::calculate_actual_weight(&T::WeightInfo::sell_complete_set, assets_len, max_cats)
        }
    }

    #[pallet::config]
    pub trait Config: frame_system::Config {
        /// The base amount of currency that must be bonded for a market approved by the
        ///  advisory committee.
        type AdvisoryBond: Get<BalanceOf<Self>>;

        type ApprovalOrigin: EnsureOrigin<<Self as frame_system::Config>::Origin>;

        type Event: From<Event<Self>> + IsType<<Self as frame_system::Config>::Event>;

        /// Common market parameters
        type MarketCommons: MarketCommonsPalletApi<
            AccountId = Self::AccountId,
            BlockNumber = Self::BlockNumber,
        >;

        /// The maximum number of categories available for categorical markets.
        type MaxCategories: Get<u16>;

        /// The minimum number of categories available for categorical markets.
        type MinCategories: Get<u16>;

        type Shares: ZeitgeistMultiReservableCurrency<
            Self::AccountId,
            Balance = BalanceOf<Self>,
            CurrencyId = Asset<MarketIdOf<Self>>,
        >;

        /// Responsable for handling disputes
        type SimpleDisputes: SimpleDisputesPalletApi<
            AccountId = Self::AccountId,
            BlockNumber = Self::BlockNumber,
            MarketId = MarketIdOf<Self>,
            Origin = Self::Origin,
        >;

        /// The module identifier.
        type PalletId: Get<PalletId>;

        /// The base amount of currency that must be bonded to ensure the oracle reports
        ///  in a timely manner.
        type OracleBond: Get<BalanceOf<Self>>;

        /// The number of blocks the reporting period remains open.
        type ReportingPeriod: Get<Self::BlockNumber>;

        /// Slash
        type Slash: OnUnbalanced<NegativeImbalanceOf<Self>>;

        /// Swaps pallet API
        type Swaps: Swaps<Self::AccountId, Balance = BalanceOf<Self>, MarketId = MarketIdOf<Self>>;

        /// The type that offers timestamping functionality
        type Timestamp: Time;

        /// The base amount of currency that must be bonded for a permissionless market,
        /// guaranteeing that it will resolve as anything but `Invalid`.
        type ValidityBond: Get<BalanceOf<Self>>;

        ///Weights generated by benchmarks
        type WeightInfo: WeightInfoZeitgeist;
    }

    #[pallet::error]
    pub enum Error<T> {
        /// End block is too soon.
        EndBlockTooSoon,
        /// End timestamp is too soon.
        EndTimestampTooSoon,
        /// Market account does not have enough funds to pay out.
        InsufficientFundsInMarketAccount,
        /// Sender does not have enough share balance.
        InsufficientShareBalance,
        /// An invalid Hash was included in a multihash parameter
        InvalidMultihash,
        /// An invalid market type was found.
        InvalidMarketType,
        /// A market with the provided ID does not exist.
        MarketDoesNotExist,
        /// The market status is something other than active.
        MarketNotActive,
        /// Sender does not have enough balance to buy shares.
        NotEnoughBalance,
        /// The outcome being reported is out of range.
        OutcomeOutOfRange,
        /// Market is already reported on.
        MarketAlreadyReported,
        /// A reported market was expected
        MarketIsNotReported,
        /// A resolved market was expected
        MarketIsNotResolved,
        /// The market is not closed.
        MarketNotClosed,
        /// The number of categories for a categorical market is too low
        NotEnoughCategories,
        /// The user has no winning balance.
        NoWinningBalance,
        /// The report is not coming from designated oracle.
        ReporterNotOracle,
        /// A swap pool already exists for this market.
        SwapPoolExists,
        /// Too many categories for a categorical market
        TooManyCategories,
    }

    #[pallet::event]
    #[pallet::generate_deposit(fn deposit_event)]
    pub enum Event<T>
    where
        T: Config,
    {
        /// A complete set of shares has been bought [market_id, buyer]
        BoughtCompleteSet(MarketIdOf<T>, <T as frame_system::Config>::AccountId),
        /// A market has been approved [market_id]
        MarketApproved(MarketIdOf<T>),
        /// A market has been created [market_id, creator]
        MarketCreated(MarketIdOf<T>, <T as frame_system::Config>::AccountId),
        /// A pending market has been cancelled. [market_id, creator]
        MarketCancelled(MarketIdOf<T>),
        /// A market has been disputed [market_id, new_outcome]
        MarketDisputed(MarketIdOf<T>, OutcomeReport),
        /// NOTE: Maybe we should only allow rejections.
        /// A pending market has been rejected as invalid. [market_id]
        MarketRejected(MarketIdOf<T>),
        /// A market has been reported on [market_id, reported_outcome]
        MarketReported(MarketIdOf<T>, OutcomeReport),
        /// A market has been resolved [market_id, real_outcome]
        MarketResolved(MarketIdOf<T>, u16),
        /// A complete set of shares has been sold [market_id, seller]
        SoldCompleteSet(MarketIdOf<T>, <T as frame_system::Config>::AccountId),
    }

    #[pallet::hooks]
    impl<T: Config> Hooks<T::BlockNumber> for Pallet<T> {
        fn on_initialize(now: T::BlockNumber) -> Weight {
            let mut total_weight: Weight = 0;
            let rslt = T::SimpleDisputes::on_resolution(now, |market, rc| {
                let weight = Self::calculate_internal_resolve_weight(market, rc);
                total_weight = total_weight.saturating_add(weight);
            });
            with_transaction(|| match rslt {
                Err(err) => {
                    log::error!("Block {:?} was not initialized. Error: {:?}", now, err);
                    TransactionOutcome::Rollback(())
                }
                Ok(_) => TransactionOutcome::Commit(()),
            });
            total_weight
        }

        fn on_runtime_upgrade() -> Weight {
            crate::migrations::_0_1_2_move_storage_to_simple_disputes_and_market_commons::migrate::<T>(
            )
        }
    }

    #[pallet::pallet]
    pub struct Pallet<T>(PhantomData<T>);

    impl<T: Config> Pallet<T> {
        pub fn outcome_assets(
            market_id: MarketIdOf<T>,
            market: &Market<T::AccountId, T::BlockNumber>,
        ) -> Vec<Asset<MarketIdOf<T>>> {
            match market.market_type {
                MarketType::Categorical(categories) => {
                    let mut assets = Vec::new();
                    for i in 0..categories {
                        assets.push(Asset::CategoricalOutcome(market_id, i));
                    }
                    assets
                }
                MarketType::Scalar(_) => {
                    vec![
                        Asset::ScalarOutcome(market_id, ScalarPosition::Long),
                        Asset::ScalarOutcome(market_id, ScalarPosition::Short),
                    ]
                }
            }
        }

        pub(crate) fn market_account(market_id: MarketIdOf<T>) -> T::AccountId {
            T::PalletId::get().into_sub_account(market_id)
        }

        /// Clears this market from being stored for automatic resolution.
        fn clear_auto_resolve(market_id: &MarketIdOf<T>) -> Result<(), dispatch::DispatchError> {
            let market = T::MarketCommons::market(&market_id)?;
            if market.status == MarketStatus::Reported {
                let report = market.report.ok_or(Error::<T>::MarketIsNotReported)?;
                let mut old_reports_per_block =
                    T::SimpleDisputes::market_ids_per_report_block(&report.at)?;
                remove_item::<MarketIdOf<T>>(&mut old_reports_per_block, *market_id);
                T::SimpleDisputes::insert_market_id_per_report_block(
                    report.at,
                    old_reports_per_block,
                );
            }
            if market.status == MarketStatus::Disputed {
                let disputes = T::SimpleDisputes::disputes(market_id)?;
                let num_disputes = disputes.len();
                let prev_dispute = disputes[num_disputes - 1].clone();
                let at = prev_dispute.at;
                let mut old_disputes_per_block =
                    T::SimpleDisputes::market_ids_per_dispute_block(&at)?;
                remove_item::<MarketIdOf<T>>(&mut old_disputes_per_block, *market_id);
                T::SimpleDisputes::insert_market_id_per_dispute_block(at, old_disputes_per_block);
            }

            Ok(())
        }

        pub(crate) fn do_buy_complete_set(
            who: T::AccountId,
            market_id: MarketIdOf<T>,
            amount: BalanceOf<T>,
        ) -> DispatchResultWithPostInfo {
            ensure!(CurrencyOf::<T>::free_balance(&who) >= amount, Error::<T>::NotEnoughBalance,);

            let market = T::MarketCommons::market(&market_id)?;
            ensure!(Self::is_market_active(market.end), Error::<T>::MarketNotActive);

            let market_account = Self::market_account(market_id);
            CurrencyOf::<T>::transfer(
                &who,
                &market_account,
                amount,
                ExistenceRequirement::KeepAlive,
            )?;

            let assets = Self::outcome_assets(market_id, &market);
            for asset in assets.iter() {
                T::Shares::deposit(*asset, &who, amount)?;
            }

            Self::deposit_event(Event::BoughtCompleteSet(market_id, who));

            let assets_len: u32 = assets.len().saturated_into();
            let max_cats: u32 = T::MaxCategories::get().into();
            Self::calculate_actual_weight(&T::WeightInfo::buy_complete_set, assets_len, max_cats)
        }

        fn calculate_actual_weight<F>(
            func: F,
            weight_parameter: u32,
            max_weight_parameter: u32,
        ) -> DispatchResultWithPostInfo
        where
            F: Fn(u32) -> Weight,
        {
            if weight_parameter == max_weight_parameter {
                Ok(None.into())
            } else {
                Ok(Some(func(weight_parameter)).into())
            }
        }

        fn calculate_internal_resolve_weight(
            market: &Market<T::AccountId, T::BlockNumber>,
            rc: ResolutionCounters,
        ) -> Weight {
            if let MarketType::Categorical(_) = market.market_type {
                if let MarketStatus::Reported = market.status {
                    T::WeightInfo::internal_resolve_categorical_reported(
                        rc.total_accounts,
                        rc.total_asset_accounts,
                        rc.total_categories,
                    )
                } else {
                    T::WeightInfo::internal_resolve_categorical_disputed(
                        rc.total_accounts,
                        rc.total_asset_accounts,
                        rc.total_categories,
                        rc.total_disputes,
                    )
                }
            } else if let MarketStatus::Reported = market.status {
                T::WeightInfo::internal_resolve_scalar_reported()
            } else {
                T::WeightInfo::internal_resolve_scalar_disputed(rc.total_disputes)
            }
        }

        fn is_market_active(end: MarketEnd<T::BlockNumber>) -> bool {
            match end {
                MarketEnd::Block(block) => {
                    let current_block = <frame_system::Pallet<T>>::block_number();
                    current_block < block
                }
                MarketEnd::Timestamp(timestamp) => {
                    let now = T::Timestamp::now();
                    now < timestamp.saturated_into()
                }
            }
        }

        fn ensure_create_market_end(end: MarketEnd<T::BlockNumber>) -> DispatchResult {
            match end {
                MarketEnd::Block(block) => {
                    let current_block = <frame_system::Pallet<T>>::block_number();
                    ensure!(current_block < block, Error::<T>::EndBlockTooSoon);
                }
                MarketEnd::Timestamp(timestamp) => {
                    let now = T::Timestamp::now();
                    ensure!(now < timestamp.saturated_into(), Error::<T>::EndTimestampTooSoon);
                }
            };

            Ok(())
        }
    }

    fn remove_item<I: cmp::PartialEq + Copy>(items: &mut Vec<I>, item: I) {
        let pos = items.iter().position(|&i| i == item).unwrap();
        items.swap_remove(pos);
    }
}
