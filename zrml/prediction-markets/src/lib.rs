//! # Prediction Markets
//!
//! A module for creating, reporting, and disputing prediction markets.
//!
//! ## Overview
//!
//! Prediction markets are speculative markets that trade on future outcomes. While
//! a prediction market is active, traders can permissionlessly trade on outcome assets.
//! Complete set of outcome assets can be generated by exchanging base currency (ZTG) at
//! a 1:1 exchange rate, meaning that 1 ZTG is used to generate 1 of each outcome asset
//! of the market. A complete set of outcome assets (an equal amount of each outcome asset
//! for a market), can be used to do the reverse exchange, being used to exchange 1:1 back to ZTG.
//!
//! This pallet implements a two types of prediction markets:
//! - **Categorical market** - A market that can trade up to 8 different categories of outcomes. In the most
//! simple case, when the outcomes are binary options (i.e. "YES" or "NO") the market has only two categories.
//! - **Scalar markets** - A market that trades `Long` or `Short` positions on a range of outcomes.
//!
//! ## Interface
//!
//! ### Dispatches
//!
//! #### Public Dispatches
//!
//! - `buy_complete_set` - Buys a complete set of outcome assets for a market.
//! - `cancel_pending_market` - Allows the proposer of a market that is currently in a `Proposed` state to cancel the market proposal.
//! - `create_categorical_market` - Creates a new categorical market.
//! - `create_market_and_deploy_assets` - Create a market, buy a complete set of the assets used
//!    within and deploy an arbitrary amount of those that's greater than the minimum amount.
//! - `create_scalar_market` - Creates a new scalar market.
//! - `deploy_swap_pool_for_market` - Deploys a single "canonical" pool for a market.
//! - `dispute` - Submits a disputed outcome for a market.
//! - `global_dispute` - `unimplemented!()`
//! - `redeem_shares` - Redeems the winning shares for a market.
//! - `report` - Reports an outcome for a market.
//! - `sell_complete_set` - Sells a complete set of outcome assets for a market.
//!
//! #### Admin Dispatches
//!
//! The administrative dispatches are used to perform admin functions on chain. Currently, the
//! admin functions can only be called by the `ApprovalOrigin` origin.
//!
//! - `admin_destroy_market` - Destroys a market and all related assets, regardless of its state.
//! - `admin_move_market_to_closed` - Immediately moves a market that is an `Active` state to closed.
//! - `admin_move_market_to_resolved` - Immediately moves a market that is `Reported` or `Disputed` to resolved.
//!
//! #### `ApprovalOrigin` Dispatches
//!
//! The `ApprovalOrigin` is meant to be the advisory committee, the on-chain governing body of Zeitgeist
//! that is responsible for maintaining a list of high quality markets and slash low quality markets.
//!
//! - `approve_market` - Approves a `Proposed` market that is waiting approval from the Advisory Committee.
//! - `reject_market` -  Rejects a `Proposed` market that is waiting approval from the Advisory Committee.

#![cfg_attr(not(feature = "std"), no_std)]

extern crate alloc;

mod benchmarks;
mod migrations;
pub mod mock;
mod tests;
pub mod weights;

pub use pallet::*;

#[frame_support::pallet]
mod pallet {
    use crate::weights::*;
    use alloc::{vec, vec::Vec};
    use core::{cmp, marker::PhantomData, ops::RangeInclusive};
    use frame_support::{
        dispatch::{DispatchResultWithPostInfo, Weight},
        ensure, log,
        pallet_prelude::{StorageMap, ValueQuery},
        storage::{with_transaction, TransactionOutcome},
        traits::{
            Currency, EnsureOrigin, ExistenceRequirement, Get, Hooks, Imbalance, IsType,
            NamedReservableCurrency, OnUnbalanced,
        },
        transactional, Blake2_128Concat, PalletId, Twox64Concat,
    };
    use frame_system::{ensure_signed, pallet_prelude::OriginFor};
    use orml_traits::MultiCurrency;
    use sp_arithmetic::per_things::Perbill;
    use sp_runtime::{
        traits::{AccountIdConversion, CheckedDiv, Saturating, Zero},
        ArithmeticError, DispatchError, DispatchResult, SaturatedConversion,
    };
    use zeitgeist_primitives::{
        constants::{PmPalletId, MILLISECS_PER_BLOCK},
        traits::{DisputeApi, Swaps, ZeitgeistMultiReservableCurrency},
        types::{
            Asset, Market, MarketCreation, MarketDispute, MarketDisputeMechanism, MarketPeriod,
            MarketStatus, MarketType, MultiHash, OutcomeReport, Report, ScalarPosition,
        },
    };
    use zrml_liquidity_mining::LiquidityMiningPalletApi;
    use zrml_market_commons::MarketCommonsPalletApi;

    pub(crate) const RESERVE_ID: [u8; 8] = PmPalletId::get().0;

    pub(crate) type BalanceOf<T> =
        <CurrencyOf<T> as Currency<<T as frame_system::Config>::AccountId>>::Balance;
    pub(crate) type CurrencyOf<T> =
        <<T as Config>::MarketCommons as MarketCommonsPalletApi>::Currency;
    pub(crate) type MarketIdOf<T> =
        <<T as Config>::MarketCommons as MarketCommonsPalletApi>::MarketId;
    type NegativeImbalanceOf<T> =
        <CurrencyOf<T> as Currency<<T as frame_system::Config>::AccountId>>::NegativeImbalance;
    pub(crate) type MomentOf<T> = <<T as Config>::MarketCommons as MarketCommonsPalletApi>::Moment;

    #[pallet::call]
    impl<T: Config> Pallet<T> {
        /// Allows the `ApprovalOrigin` to immediately destroy a market.
        ///
        /// todo: this should check if there's any outstanding funds reserved if it stays
        /// in for production
        #[pallet::weight(
            T::WeightInfo::admin_destroy_reported_market(
                4_500,
                4_500,
                T::MaxCategories::get().into()
            ).max(T::WeightInfo::admin_destroy_disputed_market(
                4_500,
                4_500,
                T::MaxCategories::get().into()
            ))
        )]
        pub fn admin_destroy_market(
            origin: OriginFor<T>,
            market_id: MarketIdOf<T>,
        ) -> DispatchResultWithPostInfo {
            T::ApprovalOrigin::ensure_origin(origin)?;

            let mut total_accounts = 0usize;
            let mut share_accounts = 0usize;
            let market = T::MarketCommons::market(&market_id)?;
            let market_status = market.status;
            let outcome_assets = Self::outcome_assets(market_id, &market);
            let outcome_assets_amount = outcome_assets.len();
            Self::clear_auto_resolve(&market_id)?;
            T::MarketCommons::remove_market(&market_id)?;

            let mut outcome_assets_iter = outcome_assets.into_iter();

            // Delete of this market's outcome assets.
            let mut manage_outcome_asset = |asset: Asset<_>| -> usize {
                let (total_accounts, accounts) = T::Shares::accounts_by_currency_id(asset);
                share_accounts = share_accounts.saturating_add(accounts.len());
                T::Shares::destroy_all(asset, accounts.iter().cloned());
                total_accounts
            };

            if let Some(first_asset) = outcome_assets_iter.next() {
                total_accounts = manage_outcome_asset(first_asset);
            }
            for asset in outcome_assets_iter {
                let _ = manage_outcome_asset(asset);
            }

            // Weight correction
            if market_status == MarketStatus::Reported {
                Ok(Some(T::WeightInfo::admin_destroy_reported_market(
                    total_accounts.saturated_into(),
                    share_accounts.saturated_into(),
                    outcome_assets_amount.saturated_into(),
                ))
                .into())
            } else if market_status == MarketStatus::Disputed {
                Ok(Some(T::WeightInfo::admin_destroy_disputed_market(
                    total_accounts.saturated_into(),
                    share_accounts.saturated_into(),
                    outcome_assets_amount.saturated_into(),
                ))
                .into())
            } else {
                Ok(None.into())
            }
        }

        /// Allows the `ApprovalOrigin` to immediately move an open market to closed.
        //
        // ***** IMPORTANT *****
        //
        // Within the same block, operations that interact with the activeness of the same
        // market will behave differently before and after this call.
        #[pallet::weight(T::WeightInfo::admin_move_market_to_closed())]
        pub fn admin_move_market_to_closed(
            origin: OriginFor<T>,
            market_id: MarketIdOf<T>,
        ) -> DispatchResult {
            T::ApprovalOrigin::ensure_origin(origin)?;
            T::MarketCommons::mutate_market(&market_id, |m| {
                m.period = match m.period {
                    MarketPeriod::Block(ref range) => {
                        let current_block = <frame_system::Pallet<T>>::block_number();
                        MarketPeriod::Block(range.start..current_block)
                    }
                    MarketPeriod::Timestamp(ref range) => {
                        let now = T::MarketCommons::now();
                        MarketPeriod::Timestamp(range.start..now)
                    }
                };
                Ok(())
            })?;
            Ok(())
        }

        /// Allows the `ApprovalOrigin` to immediately move a reported or disputed
        /// market to resolved.
        ////
        #[pallet::weight(T::WeightInfo::admin_move_market_to_resolved_overhead()
            .saturating_add(T::WeightInfo::internal_resolve_categorical_reported(
                4_200,
                4_200,
                T::MaxCategories::get().into()
            ).saturating_sub(T::WeightInfo::internal_resolve_scalar_reported())
        ))]
        pub fn admin_move_market_to_resolved(
            origin: OriginFor<T>,
            market_id: MarketIdOf<T>,
        ) -> DispatchResultWithPostInfo {
            T::ApprovalOrigin::ensure_origin(origin)?;

            let market = T::MarketCommons::market(&market_id)?;
            ensure!(
                market.status == MarketStatus::Reported || market.status == MarketStatus::Disputed,
                "not reported nor disputed"
            );
            Self::clear_auto_resolve(&market_id)?;
            let market = T::MarketCommons::market(&market_id)?;
            let weight = Self::on_resolution(&market_id, &market)?;
            Ok(Some(weight).into())
        }

        /// Approves a market that is waiting for approval from the
        /// advisory committee.
        ///
        /// NOTE: Returns the proposer's bond since the market has been
        /// deemed valid by an advisory committee.
        ///
        /// NOTE: Can only be called by the `ApprovalOrigin`.
        ///
        #[pallet::weight(T::WeightInfo::approve_market())]
        pub fn approve_market(origin: OriginFor<T>, market_id: MarketIdOf<T>) -> DispatchResult {
            T::ApprovalOrigin::ensure_origin(origin)?;

            let market = T::MarketCommons::market(&market_id)?;

            let creator = market.creator;

            CurrencyOf::<T>::unreserve_named(&RESERVE_ID, &creator, T::AdvisoryBond::get());
            T::MarketCommons::mutate_market(&market_id, |m| {
                m.status = MarketStatus::Active;
                Ok(())
            })?;

            Self::deposit_event(Event::MarketApproved(market_id));
            Ok(())
        }

        /// Buys the complete set of outcome shares of a market. For example, when calling this
        /// function on a categorical market with five different outcomes, five different shares
        /// will be transferred to the callee.
        ///
        /// The amount of each share will equal the provided `amount` parameter.
        ///
        /// NOTE: This is the only way to create new shares.
        // Note: `buy_complete_set` weight consumption is dependent on how many assets exists.
        // Unfortunately this information can only be retrieved with a storage call, therefore
        // The worst-case scenario is assumed and the correct weight is calculated at the end of this function.
        // This also occurs in numerous other functions.
        #[pallet::weight(
            T::WeightInfo::buy_complete_set(T::MaxCategories::get().into())
        )]
        #[transactional]
        pub fn buy_complete_set(
            origin: OriginFor<T>,
            market_id: MarketIdOf<T>,
            #[pallet::compact] amount: BalanceOf<T>,
        ) -> DispatchResultWithPostInfo {
            let sender = ensure_signed(origin)?;
            Self::do_buy_complete_set(sender, market_id, amount)
        }

        #[pallet::weight(T::WeightInfo::dispute(T::MaxDisputes::get()))]
        pub fn dispute(
            origin: OriginFor<T>,
            market_id: MarketIdOf<T>,
            outcome: OutcomeReport,
        ) -> DispatchResultWithPostInfo {
            let who = ensure_signed(origin)?;
            let disputes = Disputes::<T>::get(market_id);
            let curr_block_num = <frame_system::Pallet<T>>::block_number();
            let market = T::MarketCommons::market(&market_id)?;
            let num_disputes: u32 = disputes.len().saturated_into();
            let outcome_clone = outcome.clone();
            Self::validate_dispute(&disputes, &market, num_disputes, &outcome)?;
            CurrencyOf::<T>::reserve_named(
                &RESERVE_ID,
                &who,
                default_dispute_bond::<T>(disputes.len()),
            )?;
            match market.mdm {
                MarketDisputeMechanism::Authorized(_) => {
                    T::Authorized::on_dispute(&disputes, &market_id, &market)?
                }
                MarketDisputeMechanism::Court => {
                    T::Court::on_dispute(&disputes, &market_id, &market)?
                }
                MarketDisputeMechanism::SimpleDisputes => {
                    T::SimpleDisputes::on_dispute(&disputes, &market_id, &market)?
                }
            }
            Self::remove_last_dispute_from_market_ids_per_dispute_block(&disputes, &market_id)?;
            Self::set_market_as_disputed(&market, &market_id)?;
            <Disputes<T>>::mutate(market_id, |disputes| {
                disputes.push(MarketDispute { at: curr_block_num, by: who, outcome });
            });
            <MarketIdsPerDisputeBlock<T>>::mutate(curr_block_num, |ids| {
                ids.push(market_id);
            });
            Self::deposit_event(Event::MarketDisputed(market_id, outcome_clone));
            Self::calculate_actual_weight(
                &T::WeightInfo::dispute,
                num_disputes,
                T::MaxDisputes::get(),
            )
        }

        /// NOTE: Only for PoC probably - should only allow rejections
        /// in a production environment since this better aligns incentives.
        /// See also: Polkadot Treasury
        ///
        #[pallet::weight(T::WeightInfo::cancel_pending_market())]
        pub fn cancel_pending_market(
            origin: OriginFor<T>,
            market_id: MarketIdOf<T>,
        ) -> DispatchResult {
            let sender = ensure_signed(origin)?;

            let market = T::MarketCommons::market(&market_id)?;

            let creator = market.creator;
            let status = market.status;
            ensure!(creator == sender, "Canceller must be market creator.");
            ensure!(status == MarketStatus::Proposed, "Market must be pending approval.");
            // The market is being cancelled, return the deposit.
            CurrencyOf::<T>::unreserve_named(&RESERVE_ID, &creator, T::AdvisoryBond::get());
            T::MarketCommons::remove_market(&market_id)?;
            Self::deposit_event(Event::MarketCancelled(market_id));
            Ok(())
        }

        #[pallet::weight(T::WeightInfo::create_categorical_market())]
        pub fn create_categorical_market(
            origin: OriginFor<T>,
            oracle: T::AccountId,
            period: MarketPeriod<T::BlockNumber, MomentOf<T>>,
            metadata: MultiHash,
            creation: MarketCreation,
            categories: u16,
            mdm: MarketDisputeMechanism<T::AccountId>,
        ) -> DispatchResult {
            let sender = ensure_signed(origin)?;
            Self::ensure_market_is_active(&period)?;

            ensure!(categories >= T::MinCategories::get(), <Error<T>>::NotEnoughCategories);
            ensure!(categories <= T::MaxCategories::get(), <Error<T>>::TooManyCategories);

            // Require sha3-384 as multihash.
            let MultiHash::Sha3_384(multihash) = metadata;
            ensure!(multihash[0] == 0x15 && multihash[1] == 0x30, <Error<T>>::InvalidMultihash);

            let status: MarketStatus = match creation {
                MarketCreation::Permissionless => {
                    let required_bond = T::ValidityBond::get() + T::OracleBond::get();
                    CurrencyOf::<T>::reserve_named(&RESERVE_ID, &sender, required_bond)?;
                    MarketStatus::Active
                }
                MarketCreation::Advised => {
                    let required_bond = T::AdvisoryBond::get() + T::OracleBond::get();
                    CurrencyOf::<T>::reserve_named(&RESERVE_ID, &sender, required_bond)?;
                    MarketStatus::Proposed
                }
            };

            let market = Market {
                creation,
                creator_fee: 0,
                creator: sender.clone(),
                market_type: MarketType::Categorical(categories),
                mdm,
                metadata: Vec::from(multihash),
                oracle,
                period,
                report: None,
                resolved_outcome: None,
                status,
            };

            let market_id = T::MarketCommons::push_market(market.clone())?;
            Self::deposit_event(Event::MarketCreated(market_id, market, sender));

            Ok(())
        }

        /// This function combines the creation of a market, the buying of a complete set of
        /// outcome assets, the deployment of the minimum amount of outcome assets and
        /// the optional deployment of additional outcome asset.
        ///
        /// # Arguments
        ///
        /// * `oracle`: The oracle of the market who will report the correct outcome.
        /// * `end`: The ending block of the market.
        /// * `metadata`: A hash pointer to the metadata of the market.
        /// * `creation`: The creation type of the market (permissionless or advised).
        /// * `assets`: The type and the parameters of an asset (for example 5 categorical assets).
        /// * `amount`: The amount of a complete set of assets that should be bought.
        /// * `weights`: The relative denormalized weight of each asset price.
        /// * `pool_join_additional_assets`: A list of 3-tuples containing the asset amounts to
        ///     additionally deploy into the market. The first element is the asset, the market
        ///     id contained within will be replaced by the market id of the market that was just
        ///     deployed within this function call, the second element in the 3-tuple contains the
        ///     amount of that asset type that should be added as additional liquidity and the
        ///     last element within the 3-tuple contains the minimum pool amount (see Swaps pallet)
        #[pallet::weight(
            T::WeightInfo::create_scalar_market().max(T::WeightInfo::create_categorical_market())
            .saturating_add(T::WeightInfo::buy_complete_set(T::MaxCategories::get().into()))
            .saturating_add(T::WeightInfo::deploy_swap_pool_for_market(weights.len() as u32))
            // Overly generous estimation, since we have no access to Swaps WeightInfo
            // (it is loosely coupled to this pallet using a trait). Will be adjusted later
            .saturating_add(5_000_000_000.saturating_mul(pool_join_additional_assets.len() as u64))
            .saturating_add(T::DbWeight::get().reads(2 as Weight))
        )]
        pub fn create_market_and_deploy_assets(
            origin: OriginFor<T>,
            oracle: T::AccountId,
            period: MarketPeriod<T::BlockNumber, MomentOf<T>>,
            metadata: MultiHash,
            creation: MarketCreation,
            assets: MarketType,
            #[pallet::compact] amount: BalanceOf<T>,
            weights: Vec<u128>,
            pool_join_additional_assets: Vec<(Asset<MarketIdOf<T>>, BalanceOf<T>, BalanceOf<T>)>,
            mdm: MarketDisputeMechanism<T::AccountId>,
        ) -> DispatchResultWithPostInfo {
            let who = ensure_signed(origin.clone())?;
            let weight_market_creation;
            let _ = match assets {
                MarketType::Categorical(category_count) => {
                    weight_market_creation = T::WeightInfo::create_categorical_market();
                    Self::create_categorical_market(
                        origin.clone(),
                        oracle,
                        period,
                        metadata,
                        creation,
                        category_count,
                        mdm,
                    )?
                }
                MarketType::Scalar(range) => {
                    weight_market_creation = T::WeightInfo::create_scalar_market();
                    Self::create_scalar_market(
                        origin.clone(),
                        oracle,
                        period,
                        metadata,
                        creation,
                        range,
                        mdm,
                    )?
                }
            };

            let market_id = T::MarketCommons::latest_market_id()?;
            let weight_bcs = Self::buy_complete_set(origin.clone(), market_id, amount)?
                .actual_weight
                .unwrap_or_else(|| T::WeightInfo::buy_complete_set(T::MaxCategories::get().into()));
            let weight_len = weights.len().saturated_into();
            let _ = Self::deploy_swap_pool_for_market(origin, market_id, weights)?;
            let pool_id = T::MarketCommons::market_pool(&market_id)?;
            let mut weight_pool_joins = 0;

            for (mut asset_in, asset_amount, min_pool_amount) in pool_join_additional_assets {
                asset_in = match asset_in {
                    Asset::CategoricalOutcome(_, cat_idx) => {
                        Asset::CategoricalOutcome(market_id, cat_idx)
                    }
                    Asset::ScalarOutcome(_, position) => Asset::ScalarOutcome(market_id, position),
                    _ => asset_in,
                };
                let local_weight = T::Swaps::pool_join_with_exact_asset_amount(
                    who.clone(),
                    pool_id,
                    asset_in,
                    asset_amount,
                    min_pool_amount,
                )?;
                weight_pool_joins = weight_pool_joins.saturating_add(local_weight);
            }

            Ok(Some(
                weight_market_creation
                    .saturating_add(weight_bcs)
                    .saturating_add(T::WeightInfo::deploy_swap_pool_for_market(weight_len))
                    .saturating_add(weight_pool_joins)
                    .saturating_add(T::DbWeight::get().reads(2)),
            )
            .into())
        }

        #[pallet::weight(T::WeightInfo::create_scalar_market())]
        pub fn create_scalar_market(
            origin: OriginFor<T>,
            oracle: T::AccountId,
            period: MarketPeriod<T::BlockNumber, MomentOf<T>>,
            metadata: MultiHash,
            creation: MarketCreation,
            outcome_range: RangeInclusive<u128>,
            mdm: MarketDisputeMechanism<T::AccountId>,
        ) -> DispatchResult {
            let sender = ensure_signed(origin)?;
            Self::ensure_market_is_active(&period)?;

            ensure!(outcome_range.start() < outcome_range.end(), "Invalid range provided.");

            // Require sha3-384 as multihash.
            let MultiHash::Sha3_384(multihash) = metadata;
            ensure!(multihash[0] == 0x15 && multihash[1] == 0x30, <Error<T>>::InvalidMultihash);

            let status: MarketStatus = match creation {
                MarketCreation::Permissionless => {
                    let required_bond = T::ValidityBond::get() + T::OracleBond::get();
                    CurrencyOf::<T>::reserve_named(&RESERVE_ID, &sender, required_bond)?;
                    MarketStatus::Active
                }
                MarketCreation::Advised => {
                    let required_bond = T::AdvisoryBond::get() + T::OracleBond::get();
                    CurrencyOf::<T>::reserve_named(&RESERVE_ID, &sender, required_bond)?;
                    MarketStatus::Proposed
                }
            };

            let market = Market {
                creation,
                creator_fee: 0,
                creator: sender.clone(),
                market_type: MarketType::Scalar(outcome_range),
                mdm,
                metadata: Vec::from(multihash),
                oracle,
                period,
                report: None,
                resolved_outcome: None,
                status,
            };

            let market_id = T::MarketCommons::push_market(market.clone())?;
            Self::deposit_event(Event::MarketCreated(market_id, market, sender));

            Ok(())
        }

        /// Deploys a new pool for the market. This pallet keeps track of a single
        /// canonical swap pool for each market in `market_to_swap_pool`.
        ///
        /// The sender should have enough funds to cover all of the required
        /// shares to seed the pool.
        #[pallet::weight(
            T::WeightInfo::deploy_swap_pool_for_market(weights.len() as u32)
        )]
        #[transactional]
        pub fn deploy_swap_pool_for_market(
            origin: OriginFor<T>,
            market_id: MarketIdOf<T>,
            weights: Vec<u128>,
        ) -> DispatchResult {
            let sender = ensure_signed(origin)?;

            let market = T::MarketCommons::market(&market_id)?;
            Self::ensure_market_is_active(&market.period)?;

            // ensure a swap pool does not already exist
            ensure!(T::MarketCommons::market_pool(&market_id).is_err(), Error::<T>::SwapPoolExists);

            let mut assets = Self::outcome_assets(market_id, &market);
            assets.push(Asset::Ztg);

            let pool_id = T::Swaps::create_pool(sender, assets, market_id, Zero::zero(), weights)?;

            T::MarketCommons::insert_market_pool(market_id, pool_id);
            Ok(())
        }

        /// Starts a global dispute.
        ///
        /// NOTE: Requires the market to be already disputed `MaxDisputes` amount of times.
        ///
        #[pallet::weight(10_000_000)]
        pub fn global_dispute(origin: OriginFor<T>, market_id: MarketIdOf<T>) -> DispatchResult {
            let _sender = ensure_signed(origin)?;
            let _market = T::MarketCommons::market(&market_id)?;
            // TODO: implement global disputes
            Ok(())
        }

        /// Redeems the winning shares of a prediction market.
        ///
        #[pallet::weight(T::WeightInfo::redeem_shares_categorical()
            .max(T::WeightInfo::redeem_shares_scalar())
        )]
        pub fn redeem_shares(
            origin: OriginFor<T>,
            market_id: MarketIdOf<T>,
        ) -> DispatchResultWithPostInfo {
            let sender = ensure_signed(origin)?;

            let market = T::MarketCommons::market(&market_id)?;
            let market_account = Self::market_account(market_id);

            ensure!(market.status == MarketStatus::Resolved, Error::<T>::MarketIsNotResolved);

            // Check to see if the sender has any winning shares.
            let resolved_outcome =
                market.resolved_outcome.ok_or(Error::<T>::MarketIsNotResolved)?;

            let winning_assets = match resolved_outcome {
                OutcomeReport::Categorical(category_index) => {
                    let winning_currency_id = Asset::CategoricalOutcome(market_id, category_index);
                    let winning_balance = T::Shares::free_balance(winning_currency_id, &sender);

                    ensure!(winning_balance > BalanceOf::<T>::zero(), Error::<T>::NoWinningBalance);

                    // Ensure the market account has enough to pay out - if this is
                    // ever not true then we have an accounting problem.
                    ensure!(
                        CurrencyOf::<T>::free_balance(&market_account) >= winning_balance,
                        Error::<T>::InsufficientFundsInMarketAccount,
                    );

                    vec![(winning_currency_id, winning_balance, winning_balance)]
                }
                OutcomeReport::Scalar(value) => {
                    let long_currency_id = Asset::ScalarOutcome(market_id, ScalarPosition::Long);
                    let short_currency_id = Asset::ScalarOutcome(market_id, ScalarPosition::Short);
                    let long_balance = T::Shares::free_balance(long_currency_id, &sender);
                    let short_balance = T::Shares::free_balance(short_currency_id, &sender);

                    ensure!(
                        long_balance > BalanceOf::<T>::zero()
                            || short_balance > BalanceOf::<T>::zero(),
                        Error::<T>::NoWinningBalance
                    );

                    let bound = if let MarketType::Scalar(range) = market.market_type {
                        range
                    } else {
                        return Err(Error::<T>::InvalidMarketType.into());
                    };

                    let calc_payouts = |final_value: u128,
                                        low: u128,
                                        high: u128|
                     -> (Perbill, Perbill) {
                        if final_value <= low {
                            return (Perbill::zero(), Perbill::one());
                        }
                        if final_value >= high {
                            return (Perbill::one(), Perbill::zero());
                        }

                        let payout_long: Perbill = Perbill::from_rational(
                            final_value.saturating_sub(low),
                            high.saturating_sub(low),
                        );
                        let payout_short: Perbill = Perbill::from_parts(
                            Perbill::one().deconstruct().saturating_sub(payout_long.deconstruct()),
                        );
                        (payout_long, payout_short)
                    };

                    let (long_percent, short_percent) =
                        calc_payouts(value, *bound.start(), *bound.end());

                    let long_payout = long_percent.mul_floor(long_balance);
                    let short_payout = short_percent.mul_floor(short_balance);
                    // Ensure the market account has enough to pay out - if this is
                    // ever not true then we have an accounting problem.
                    ensure!(
                        CurrencyOf::<T>::free_balance(&market_account)
                            >= long_payout + short_payout,
                        Error::<T>::InsufficientFundsInMarketAccount,
                    );

                    vec![
                        (long_currency_id, long_payout, long_balance),
                        (short_currency_id, short_payout, short_balance),
                    ]
                }
            };

            for (currency_id, payout, balance) in winning_assets {
                // Destroy the shares.
                T::Shares::slash(currency_id, &sender, balance);

                // Pay out the winner.
                let remaining_bal = CurrencyOf::<T>::free_balance(&market_account);

                CurrencyOf::<T>::transfer(
                    &market_account,
                    &sender,
                    payout.min(remaining_bal),
                    ExistenceRequirement::AllowDeath,
                )?;
            }

            // Weight correction
            if let OutcomeReport::Categorical(_) = resolved_outcome {
                return Ok(Some(T::WeightInfo::redeem_shares_categorical()).into());
            } else if let OutcomeReport::Scalar(_) = resolved_outcome {
                return Ok(Some(T::WeightInfo::redeem_shares_scalar()).into());
            }

            Ok(None.into())
        }

        /// Rejects a market that is waiting for approval from the advisory
        /// committee.
        ///
        /// NOTE: Will slash the reserved `AdvisoryBond` from the market creator.
        ///
        #[pallet::weight(T::WeightInfo::reject_market())]
        pub fn reject_market(origin: OriginFor<T>, market_id: MarketIdOf<T>) -> DispatchResult {
            T::ApprovalOrigin::ensure_origin(origin)?;

            let market = T::MarketCommons::market(&market_id)?;
            let creator = market.creator;
            let (imbalance, _) = CurrencyOf::<T>::slash_reserved_named(
                &RESERVE_ID,
                &creator,
                T::AdvisoryBond::get(),
            );
            // Slashes the imbalance.
            T::Slash::on_unbalanced(imbalance);
            T::MarketCommons::remove_market(&market_id)?;
            Self::deposit_event(Event::MarketRejected(market_id));
            Ok(())
        }

        /// Reports the outcome of a market.
        ///
        #[pallet::weight(T::WeightInfo::report())]
        pub fn report(
            origin: OriginFor<T>,
            market_id: MarketIdOf<T>,
            outcome: OutcomeReport,
        ) -> DispatchResult {
            let sender = ensure_signed(origin.clone())?;

            let current_block = <frame_system::Pallet<T>>::block_number();

            T::MarketCommons::mutate_market(&market_id, |market| {
                // TODO make this a conditional check
                // ensure!(outcome <= market.outcomes(), Error::<T>::OutcomeOutOfRange);
                ensure!(market.report.is_none(), Error::<T>::MarketAlreadyReported);

                Self::ensure_market_is_closed(&market.period)?;

                let mut should_check_origin = false;
                match market.period {
                    MarketPeriod::Block(ref range) => {
                        if current_block <= range.end + T::ReportingPeriod::get().into() {
                            should_check_origin = true;
                        }
                    }
                    MarketPeriod::Timestamp(ref range) => {
                        let rp_moment: MomentOf<T> = T::ReportingPeriod::get().into();
                        let reporting_period_in_ms = rp_moment * MILLISECS_PER_BLOCK.into();
                        if T::MarketCommons::now() <= range.end + reporting_period_in_ms {
                            should_check_origin = true;
                        }
                    }
                }

                if should_check_origin {
                    let sender_is_oracle = sender == market.oracle;
                    let origin_has_permission = T::ApprovalOrigin::ensure_origin(origin).is_ok();
                    ensure!(
                        sender_is_oracle || origin_has_permission,
                        Error::<T>::ReporterNotOracle
                    );
                }

                market.report =
                    Some(Report { at: current_block, by: sender, outcome: outcome.clone() });
                market.status = MarketStatus::Reported;

                Ok(())
            })?;

            MarketIdsPerReportBlock::<T>::mutate(&current_block, |ids| {
                ids.push(market_id);
            });

            Self::deposit_event(Event::MarketReported(market_id, outcome));
            Ok(())
        }

        /// Destroys a complete set of outcomes shares for a market.
        ///
        #[pallet::weight(
            T::WeightInfo::sell_complete_set(T::MaxCategories::get().into())
        )]
        pub fn sell_complete_set(
            origin: OriginFor<T>,
            market_id: MarketIdOf<T>,
            #[pallet::compact] amount: BalanceOf<T>,
        ) -> DispatchResultWithPostInfo {
            let sender = ensure_signed(origin)?;

            let market = T::MarketCommons::market(&market_id)?;
            Self::ensure_market_is_active(&market.period)?;

            let market_account = Self::market_account(market_id);
            ensure!(
                CurrencyOf::<T>::free_balance(&market_account) >= amount,
                "Market account does not have sufficient reserves.",
            );

            let assets = Self::outcome_assets(market_id, &market);

            // verify first.
            for asset in assets.iter() {
                // Ensures that the sender has sufficient amount of each
                // share in the set.
                ensure!(
                    T::Shares::free_balance(*asset, &sender) >= amount,
                    Error::<T>::InsufficientShareBalance,
                );
            }

            // write last.
            for asset in assets.iter() {
                T::Shares::slash(*asset, &sender, amount);
            }

            CurrencyOf::<T>::transfer(
                &market_account,
                &sender,
                amount,
                ExistenceRequirement::AllowDeath,
            )?;

            Self::deposit_event(Event::SoldCompleteSet(market_id, sender));
            let assets_len: u32 = assets.len().saturated_into();
            let max_cats: u32 = T::MaxCategories::get().into();
            Self::calculate_actual_weight(&T::WeightInfo::sell_complete_set, assets_len, max_cats)
        }
    }

    #[pallet::config]
    pub trait Config: frame_system::Config {
        /// The base amount of currency that must be bonded for a market approved by the
        ///  advisory committee.
        type AdvisoryBond: Get<BalanceOf<Self>>;

        type ApprovalOrigin: EnsureOrigin<<Self as frame_system::Config>::Origin>;

        /// See [`AuthorizedPalletApi`].
        type Authorized: zrml_authorized::AuthorizedPalletApi<
            AccountId = Self::AccountId,
            Balance = BalanceOf<Self>,
            BlockNumber = Self::BlockNumber,
            MarketId = MarketIdOf<Self>,
            Moment = MomentOf<Self>,
            Origin = Self::Origin,
        >;

        /// See [`CourtPalletApi`].
        type Court: zrml_court::CourtPalletApi<
            AccountId = Self::AccountId,
            Balance = BalanceOf<Self>,
            BlockNumber = Self::BlockNumber,
            MarketId = MarketIdOf<Self>,
            Moment = MomentOf<Self>,
            Origin = Self::Origin,
        >;

        /// The base amount of currency that must be bonded in order to create a dispute.
        type DisputeBond: Get<BalanceOf<Self>>;

        /// The additional amount of currency that must be bonded when creating a subsequent
        /// dispute.
        type DisputeFactor: Get<BalanceOf<Self>>;

        /// The number of blocks the dispute period remains open.
        type DisputePeriod: Get<Self::BlockNumber>;

        /// Event
        type Event: From<Event<Self>> + IsType<<Self as frame_system::Config>::Event>;

        type LiquidityMining: LiquidityMiningPalletApi<
            AccountId = Self::AccountId,
            Balance = BalanceOf<Self>,
            BlockNumber = Self::BlockNumber,
            MarketId = MarketIdOf<Self>,
        >;

        /// Common market parameters
        type MarketCommons: MarketCommonsPalletApi<
            AccountId = Self::AccountId,
            BlockNumber = Self::BlockNumber,
        >;

        /// The maximum number of categories available for categorical markets.
        type MaxCategories: Get<u16>;

        /// The minimum number of categories available for categorical markets.
        type MinCategories: Get<u16>;

        /// The maximum number of disputes allowed on any single market.
        type MaxDisputes: Get<u32>;

        /// Shares
        type Shares: ZeitgeistMultiReservableCurrency<
            Self::AccountId,
            Balance = BalanceOf<Self>,
            CurrencyId = Asset<MarketIdOf<Self>>,
        >;

        /// The module identifier.
        type PalletId: Get<PalletId>;

        /// The base amount of currency that must be bonded to ensure the oracle reports
        ///  in a timely manner.
        type OracleBond: Get<BalanceOf<Self>>;

        /// The number of blocks the reporting period remains open.
        type ReportingPeriod: Get<u32>;

        /// See [`SimpleDisputesPalletApi`].
        type SimpleDisputes: DisputeApi<
            AccountId = Self::AccountId,
            Balance = BalanceOf<Self>,
            BlockNumber = Self::BlockNumber,
            MarketId = MarketIdOf<Self>,
            Moment = MomentOf<Self>,
            Origin = Self::Origin,
        >;

        /// Slash
        type Slash: OnUnbalanced<NegativeImbalanceOf<Self>>;

        /// Swaps pallet API
        type Swaps: Swaps<Self::AccountId, Balance = BalanceOf<Self>, MarketId = MarketIdOf<Self>>;

        /// The base amount of currency that must be bonded for a permissionless market,
        /// guaranteeing that it will resolve as anything but `Invalid`.
        type ValidityBond: Get<BalanceOf<Self>>;

        /// Weights generated by benchmarks
        type WeightInfo: WeightInfoZeitgeist;
    }

    #[pallet::error]
    pub enum Error<T> {
        /// Someone is trying to call `dispute` with the same outcome that is currently
        /// registered on-chain.
        CannotDisputeSameOutcome,
        /// Market account does not have enough funds to pay out.
        InsufficientFundsInMarketAccount,
        /// Sender does not have enough share balance.
        InsufficientShareBalance,
        /// An invalid Hash was included in a multihash parameter
        InvalidMultihash,
        /// An invalid market type was found.
        InvalidMarketType,
        /// Sender does not have enough balance to buy shares.
        NotEnoughBalance,
        /// The outcome being reported is out of range.
        OutcomeOutOfRange,
        /// Market is already reported on.
        MarketAlreadyReported,
        /// A reported market was expected
        MarketIsNotReported,
        /// A resolved market was expected
        MarketIsNotResolved,
        /// Market was expected to be closed
        MarketIsNotClosed,
        /// Market was expected to be active
        MarketIsNotActive,
        /// The market is not reported on.
        MarketNotReported,
        /// The maximum number of disputes has been reached.
        MaxDisputesReached,
        /// The number of categories for a categorical market is too low
        NotEnoughCategories,
        /// The user has no winning balance.
        NoWinningBalance,
        /// Submitted outcome does not match market type
        OutcomeMismatch,
        /// The report is not coming from designated oracle.
        ReporterNotOracle,
        /// A swap pool already exists for this market.
        SwapPoolExists,
        /// Too many categories for a categorical market
        TooManyCategories,
    }

    #[pallet::event]
    #[pallet::generate_deposit(fn deposit_event)]
    pub enum Event<T>
    where
        T: Config,
    {
        /// Custom addition block initialization logic wasn't successful
        BadOnInitialize,
        /// A complete set of shares has been bought \[market_id, buyer\]
        BoughtCompleteSet(MarketIdOf<T>, <T as frame_system::Config>::AccountId),
        /// A market has been approved \[market_id\]
        MarketApproved(MarketIdOf<T>),
        /// A market has been created \[market_id, creator\]
        MarketCreated(
            MarketIdOf<T>,
            Market<T::AccountId, T::BlockNumber, MomentOf<T>>,
            <T as frame_system::Config>::AccountId,
        ),
        /// A pending market has been cancelled. \[market_id, creator\]
        MarketCancelled(MarketIdOf<T>),
        /// A market has been disputed \[market_id, new_outcome\]
        MarketDisputed(MarketIdOf<T>, OutcomeReport),
        /// NOTE: Maybe we should only allow rejections.
        /// A pending market has been rejected as invalid. \[market_id\]
        MarketRejected(MarketIdOf<T>),
        /// A market has been reported on \[market_id, reported_outcome\]
        MarketReported(MarketIdOf<T>, OutcomeReport),
        /// A market has been resolved \[market_id, real_outcome\]
        MarketResolved(MarketIdOf<T>, u16),
        /// A complete set of shares has been sold \[market_id, seller\]
        SoldCompleteSet(MarketIdOf<T>, <T as frame_system::Config>::AccountId),
    }

    #[pallet::hooks]
    impl<T: Config> Hooks<T::BlockNumber> for Pallet<T> {
        fn on_initialize(now: T::BlockNumber) -> Weight {
            let mut total_weight: Weight = 0;
            let rslt = Self::resolution_manager(now, |market_id, market| {
                let weight = Self::on_resolution(market_id, market)?;
                total_weight = total_weight.saturating_add(weight);
                Ok(())
            });
            with_transaction(|| match rslt {
                Err(err) => {
                    Self::deposit_event(Event::BadOnInitialize);
                    log::error!("Block {:?} was not initialized. Error: {:?}", now, err);
                    TransactionOutcome::Rollback(())
                }
                Ok(_) => TransactionOutcome::Commit(()),
            });
            total_weight
        }
    }

    #[pallet::pallet]
    pub struct Pallet<T>(PhantomData<T>);

    /// For each market, this holds the dispute information for each dispute that's
    /// been issued.
    #[pallet::storage]
    pub type Disputes<T: Config> = StorageMap<
        _,
        Blake2_128Concat,
        MarketIdOf<T>,
        Vec<MarketDispute<T::AccountId, T::BlockNumber>>,
        ValueQuery,
    >;

    /// A mapping of market identifiers to the block they were disputed at.
    /// A market only ends up here if it was disputed.
    #[pallet::storage]
    pub type MarketIdsPerDisputeBlock<T: Config> =
        StorageMap<_, Twox64Concat, T::BlockNumber, Vec<MarketIdOf<T>>, ValueQuery>;

    /// A mapping of market identifiers to the block that they were reported on.
    #[pallet::storage]
    pub type MarketIdsPerReportBlock<T: Config> =
        StorageMap<_, Twox64Concat, T::BlockNumber, Vec<MarketIdOf<T>>, ValueQuery>;

    impl<T: Config> Pallet<T> {
        pub fn outcome_assets(
            market_id: MarketIdOf<T>,
            market: &Market<T::AccountId, T::BlockNumber, MomentOf<T>>,
        ) -> Vec<Asset<MarketIdOf<T>>> {
            match market.market_type {
                MarketType::Categorical(categories) => {
                    let mut assets = Vec::new();
                    for i in 0..categories {
                        assets.push(Asset::CategoricalOutcome(market_id, i));
                    }
                    assets
                }
                MarketType::Scalar(_) => {
                    vec![
                        Asset::ScalarOutcome(market_id, ScalarPosition::Long),
                        Asset::ScalarOutcome(market_id, ScalarPosition::Short),
                    ]
                }
            }
        }

        pub(crate) fn market_account(market_id: MarketIdOf<T>) -> T::AccountId {
            T::PalletId::get().into_sub_account(market_id)
        }

        /// Clears this market from being stored for automatic resolution.
        fn clear_auto_resolve(market_id: &MarketIdOf<T>) -> DispatchResult {
            let market = T::MarketCommons::market(market_id)?;
            if market.status == MarketStatus::Reported {
                let report = market.report.ok_or(Error::<T>::MarketIsNotReported)?;
                MarketIdsPerReportBlock::<T>::mutate(&report.at, |mut ids| {
                    remove_item::<MarketIdOf<T>>(&mut ids, market_id);
                });
            }
            if market.status == MarketStatus::Disputed {
                let disputes = Disputes::<T>::get(market_id);
                if let Some(last_dispute) = disputes.last() {
                    let at = last_dispute.at;
                    let mut old_disputes_per_block = MarketIdsPerDisputeBlock::<T>::get(&at);
                    remove_item::<MarketIdOf<T>>(&mut old_disputes_per_block, market_id);
                    MarketIdsPerDisputeBlock::<T>::mutate(&at, |mut ids| {
                        remove_item::<MarketIdOf<T>>(&mut ids, market_id);
                    });
                }
            }

            Ok(())
        }

        pub(crate) fn do_buy_complete_set(
            who: T::AccountId,
            market_id: MarketIdOf<T>,
            amount: BalanceOf<T>,
        ) -> DispatchResultWithPostInfo {
            ensure!(CurrencyOf::<T>::free_balance(&who) >= amount, Error::<T>::NotEnoughBalance,);

            let market = T::MarketCommons::market(&market_id)?;
            Self::ensure_market_is_active(&market.period)?;

            let market_account = Self::market_account(market_id);
            CurrencyOf::<T>::transfer(
                &who,
                &market_account,
                amount,
                ExistenceRequirement::KeepAlive,
            )?;

            let assets = Self::outcome_assets(market_id, &market);
            for asset in assets.iter() {
                T::Shares::deposit(*asset, &who, amount)?;
            }

            Self::deposit_event(Event::BoughtCompleteSet(market_id, who));

            let assets_len: u32 = assets.len().saturated_into();
            let max_cats: u32 = T::MaxCategories::get().into();
            Self::calculate_actual_weight(&T::WeightInfo::buy_complete_set, assets_len, max_cats)
        }

        fn calculate_actual_weight<F>(
            func: F,
            weight_parameter: u32,
            max_weight_parameter: u32,
        ) -> DispatchResultWithPostInfo
        where
            F: Fn(u32) -> Weight,
        {
            if weight_parameter == max_weight_parameter {
                Ok(None.into())
            } else {
                Ok(Some(func(weight_parameter)).into())
            }
        }

        fn calculate_internal_resolve_weight(
            market: &Market<T::AccountId, T::BlockNumber, MomentOf<T>>,
            total_accounts: u32,
            total_asset_accounts: u32,
            total_categories: u32,
            total_disputes: u32,
        ) -> Weight {
            if let MarketType::Categorical(_) = market.market_type {
                if let MarketStatus::Reported = market.status {
                    T::WeightInfo::internal_resolve_categorical_reported(
                        total_accounts,
                        total_asset_accounts,
                        total_categories,
                    )
                } else {
                    T::WeightInfo::internal_resolve_categorical_disputed(
                        total_accounts,
                        total_asset_accounts,
                        total_categories,
                        total_disputes,
                    )
                }
            } else if let MarketStatus::Reported = market.status {
                T::WeightInfo::internal_resolve_scalar_reported()
            } else {
                T::WeightInfo::internal_resolve_scalar_disputed(total_disputes)
            }
        }

        fn ensure_can_not_dispute_the_same_outcome(
            disputes: &[MarketDispute<T::AccountId, T::BlockNumber>],
            outcome: &OutcomeReport,
        ) -> DispatchResult {
            if let Some(last_dispute) = disputes.last() {
                ensure!(&last_dispute.outcome != outcome, Error::<T>::CannotDisputeSameOutcome);
            }
            Ok(())
        }

        // Must be `MarketStatus::Active` and period within range
        fn ensure_market_is_active(
            period: &MarketPeriod<T::BlockNumber, MomentOf<T>>,
        ) -> DispatchResult {
            ensure!(
                match period {
                    MarketPeriod::Block(range) => {
                        <frame_system::Pallet<T>>::block_number() < range.end
                    }
                    MarketPeriod::Timestamp(range) => {
                        T::MarketCommons::now() < range.end
                    }
                },
                Error::<T>::MarketIsNotActive
            );
            Ok(())
        }

        // Must NOT be `MarketStatus::Active` and period outside of range
        fn ensure_market_is_closed(
            period: &MarketPeriod<T::BlockNumber, MomentOf<T>>,
        ) -> DispatchResult {
            ensure!(
                match period {
                    MarketPeriod::Block(range) => {
                        <frame_system::Pallet<T>>::block_number() >= range.end
                    }
                    MarketPeriod::Timestamp(range) => {
                        T::MarketCommons::now() >= range.end
                    }
                },
                Error::<T>::MarketIsNotClosed
            );
            Ok(())
        }

        #[inline]
        fn ensure_disputes_does_not_exceed_max_disputes(num_disputes: u32) -> DispatchResult {
            ensure!(num_disputes < T::MaxDisputes::get(), Error::<T>::MaxDisputesReached);
            Ok(())
        }

        fn ensure_outcome_matches_market_type(
            market: &Market<T::AccountId, T::BlockNumber, MomentOf<T>>,
            outcome: &OutcomeReport,
        ) -> DispatchResult {
            if let OutcomeReport::Categorical(ref inner) = outcome {
                if let MarketType::Categorical(ref categories) = market.market_type {
                    ensure!(inner < categories, Error::<T>::OutcomeOutOfRange);
                } else {
                    return Err(Error::<T>::OutcomeMismatch.into());
                }
            }
            if let OutcomeReport::Scalar(ref inner) = outcome {
                if let MarketType::Scalar(ref outcome_range) = market.market_type {
                    ensure!(
                        inner >= outcome_range.start() && inner <= outcome_range.end(),
                        Error::<T>::OutcomeOutOfRange
                    );
                } else {
                    return Err(Error::<T>::OutcomeMismatch.into());
                }
            }
            Ok(())
        }

        // If a market is categorical, destroys all non-winning assets.
        fn manage_resolved_categorical_market(
            market: &Market<T::AccountId, T::BlockNumber, MomentOf<T>>,
            market_id: &MarketIdOf<T>,
            outcome_report: &OutcomeReport,
        ) -> Result<[usize; 3], DispatchError> {
            let mut total_accounts: usize = 0;
            let mut total_asset_accounts: usize = 0;
            let mut total_categories: usize = 0;

            if let MarketType::Categorical(_) = market.market_type {
                if let OutcomeReport::Categorical(winning_asset_idx) = *outcome_report {
                    let assets = Self::outcome_assets(*market_id, market);
                    total_categories = assets.len().saturated_into();

                    let mut assets_iter = assets.iter().cloned();
                    let mut manage_asset = |asset: Asset<_>, winning_asset_idx| {
                        if let Asset::CategoricalOutcome(_, idx) = asset {
                            if idx == winning_asset_idx {
                                return 0;
                            }
                            let (total_accounts, accounts) =
                                T::Shares::accounts_by_currency_id(asset);
                            total_asset_accounts =
                                total_asset_accounts.saturating_add(accounts.len());
                            T::Shares::destroy_all(asset, accounts.iter().cloned());
                            total_accounts
                        } else {
                            0
                        }
                    };

                    if let Some(first_asset) = assets_iter.next() {
                        total_accounts = manage_asset(first_asset, winning_asset_idx);
                    }
                    for asset in assets_iter {
                        let _ = manage_asset(asset, winning_asset_idx);
                    }
                }
            }

            Ok([total_accounts, total_asset_accounts, total_categories])
        }

        fn on_resolution(
            market_id: &MarketIdOf<T>,
            market: &Market<T::AccountId, T::BlockNumber, MomentOf<T>>,
        ) -> Result<u64, DispatchError> {
            CurrencyOf::<T>::unreserve_named(&RESERVE_ID, &market.creator, T::ValidityBond::get());

            let disputes = Disputes::<T>::get(market_id);
            let resolved_outcome = match market.mdm {
                MarketDisputeMechanism::Authorized(_) => {
                    T::Authorized::on_resolution(&disputes, market_id, market)?
                }
                MarketDisputeMechanism::Court => {
                    T::Court::on_resolution(&disputes, market_id, market)?
                }
                MarketDisputeMechanism::SimpleDisputes => {
                    T::SimpleDisputes::on_resolution(&disputes, market_id, market)?
                }
            };

            let report = T::MarketCommons::report(market)?;

            match market.status {
                MarketStatus::Reported => {
                    // the oracle bond gets returned if the reporter was the oracle
                    if report.by == market.oracle {
                        CurrencyOf::<T>::unreserve_named(
                            &RESERVE_ID,
                            &market.creator,
                            T::OracleBond::get(),
                        );
                    } else {
                        let (imbalance, _) = CurrencyOf::<T>::slash_reserved_named(
                            &RESERVE_ID,
                            &market.creator,
                            T::OracleBond::get(),
                        );

                        // give it to the real reporter
                        CurrencyOf::<T>::resolve_creating(&report.by, imbalance);
                    }
                }
                MarketStatus::Disputed => {
                    let mut correct_reporters: Vec<T::AccountId> = Vec::new();

                    let mut overall_imbalance = NegativeImbalanceOf::<T>::zero();

                    // if the reporter reported right, return the OracleBond, otherwise
                    // slash it to pay the correct reporters
                    if report.outcome == resolved_outcome {
                        CurrencyOf::<T>::unreserve_named(
                            &RESERVE_ID,
                            &market.creator,
                            T::OracleBond::get(),
                        );
                    } else {
                        let (imbalance, _) = CurrencyOf::<T>::slash_reserved_named(
                            &RESERVE_ID,
                            &market.creator,
                            T::OracleBond::get(),
                        );

                        overall_imbalance.subsume(imbalance);
                    }

                    for (i, dispute) in disputes.iter().enumerate() {
                        let actual_bond = default_dispute_bond::<T>(i);
                        if dispute.outcome == resolved_outcome {
                            CurrencyOf::<T>::unreserve_named(&RESERVE_ID, &dispute.by, actual_bond);

                            correct_reporters.push(dispute.by.clone());
                        } else {
                            let (imbalance, _) = CurrencyOf::<T>::slash_reserved_named(
                                &RESERVE_ID,
                                &dispute.by,
                                actual_bond,
                            );
                            overall_imbalance.subsume(imbalance);
                        }
                    }

                    // fold all the imbalances into one and reward the correct reporters.
                    let reward_per_each = overall_imbalance
                        .peek()
                        .checked_div(&correct_reporters.len().saturated_into())
                        .ok_or(ArithmeticError::DivisionByZero)?;
                    for correct_reporter in &correct_reporters {
                        let (amount, leftover) = overall_imbalance.split(reward_per_each);
                        CurrencyOf::<T>::resolve_creating(correct_reporter, amount);
                        overall_imbalance = leftover;
                    }
                }
                _ => (),
            };

            Self::set_pool_to_stale(market, market_id, &resolved_outcome)?;
            T::LiquidityMining::distribute_market_incentives(market_id)?;

            let mut total_accounts = 0u32;
            let mut total_asset_accounts = 0u32;
            let mut total_categories = 0u32;

            if let Ok([local_total_accounts, local_total_asset_accounts, local_total_categories]) =
                Self::manage_resolved_categorical_market(market, market_id, &resolved_outcome)
            {
                total_accounts = local_total_accounts.saturated_into();
                total_asset_accounts = local_total_asset_accounts.saturated_into();
                total_categories = local_total_categories.saturated_into();
            }

            T::MarketCommons::mutate_market(market_id, |m| {
                m.status = MarketStatus::Resolved;
                m.resolved_outcome = Some(resolved_outcome);
                Ok(())
            })?;
            Ok(Self::calculate_internal_resolve_weight(
                market,
                total_accounts,
                total_asset_accounts,
                total_categories,
                disputes.len().saturated_into(),
            ))
        }

        fn remove_last_dispute_from_market_ids_per_dispute_block(
            disputes: &[MarketDispute<T::AccountId, T::BlockNumber>],
            market_id: &MarketIdOf<T>,
        ) -> DispatchResult {
            if let Some(last_dispute) = disputes.last() {
                let at = last_dispute.at;
                MarketIdsPerDisputeBlock::<T>::mutate(&at, |mut ids| {
                    remove_item::<MarketIdOf<T>>(&mut ids, market_id);
                });
            }
            Ok(())
        }

        fn resolution_manager<F>(now: T::BlockNumber, mut cb: F) -> DispatchResult
        where
            F: FnMut(
                &MarketIdOf<T>,
                &Market<T::AccountId, T::BlockNumber, MomentOf<T>>,
            ) -> DispatchResult,
        {
            let dispute_period = T::DisputePeriod::get();
            if now <= dispute_period {
                return Ok(());
            }

            let block = now.saturating_sub(dispute_period);

            // Resolve all regularly reported markets.
            let reported_ids = MarketIdsPerReportBlock::<T>::get(&block);
            for id in &reported_ids {
                let market = T::MarketCommons::market(id)?;
                if let MarketStatus::Reported = market.status {
                    cb(id, &market)?;
                }
            }

            // Resolve any disputed markets.
            let disputed_ids = MarketIdsPerDisputeBlock::<T>::get(&block);
            for id in &disputed_ids {
                let market = T::MarketCommons::market(id)?;
                cb(id, &market)?;
            }

            Ok(())
        }

        // If the market is already disputed, does nothing.
        fn set_market_as_disputed(
            market: &Market<T::AccountId, T::BlockNumber, MomentOf<T>>,
            market_id: &MarketIdOf<T>,
        ) -> DispatchResult {
            if market.status != MarketStatus::Disputed {
                T::MarketCommons::mutate_market(market_id, |m| {
                    m.status = MarketStatus::Disputed;
                    Ok(())
                })?;
            }
            Ok(())
        }

        // If a market has a pool that is `Active`, then changes from `Active` to `Stale`. If
        // the market does not exist or the market does not have a pool, does nothing.
        fn set_pool_to_stale(
            market: &Market<T::AccountId, T::BlockNumber, MomentOf<T>>,
            market_id: &MarketIdOf<T>,
            outcome_report: &OutcomeReport,
        ) -> DispatchResult {
            let pool_id = if let Ok(el) = T::MarketCommons::market_pool(market_id) {
                el
            } else {
                return Ok(());
            };
            let _ = T::Swaps::set_pool_as_stale(&market.market_type, pool_id, outcome_report);
            Ok(())
        }

        fn validate_dispute(
            disputes: &[MarketDispute<T::AccountId, T::BlockNumber>],
            market: &Market<T::AccountId, T::BlockNumber, MomentOf<T>>,
            num_disputes: u32,
            outcome: &OutcomeReport,
        ) -> DispatchResult {
            ensure!(market.report.is_some(), Error::<T>::MarketNotReported);
            Self::ensure_outcome_matches_market_type(market, outcome)?;
            Self::ensure_can_not_dispute_the_same_outcome(disputes, outcome)?;
            Self::ensure_disputes_does_not_exceed_max_disputes(num_disputes)?;
            Ok(())
        }
    }

    // No-one can bound more than BalanceOf<T>, therefore, this functions saturates
    pub fn default_dispute_bond<T>(n: usize) -> BalanceOf<T>
    where
        T: Config,
    {
        T::DisputeBond::get().saturating_add(
            T::DisputeFactor::get().saturating_mul(n.saturated_into::<u32>().into()),
        )
    }

    fn remove_item<I: cmp::PartialEq>(items: &mut Vec<I>, item: &I) {
        if let Some(pos) = items.iter().position(|i| i == item) {
            items.swap_remove(pos);
        }
    }
}
